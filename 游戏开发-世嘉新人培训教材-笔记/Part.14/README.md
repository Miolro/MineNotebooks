# 第十四章 绘制立体物体

## 14.1 关于类库

相比之前的库没有了 drawTriangle2D 和传递 createTexture 时只要传入文件名意外没什么改动

### 14.1.1 纹理注册

在`在十四章`之前我们需要手动载入图片文件还要解析 DDS 文件，但是有一个好消息，我们现在只要提供文件名就可以自动载入并注册图形文件

```C++
 Framework f = Framework::instance();
 Texture* t;
 f.createTexture(&t,"aho.tga");
```

使用 getTextureSizes()获取纹理尺寸，原始素材宽高值，和修改为 2 的 N 次放的宽高值

## 14.2 开始制作 3D 动作游戏《机甲大战》

- 首先一个问题就是之前的视野都是固定的，但是现在随着移动视角视野也是一起变动的
- 在 3D 空间中,物体越远，看起来越小
- 还有就是遮挡问题，近距离的物体会把远处的物体遮挡
- 还有一个是立体感方面的问题,`2D只不过是把内存中的抽象数据Flag给具象成一个个图片`， 但是在 3D 中需要考虑环境因素比如阴影光影，需要通过明暗来突出 3D 空间的立体感
- 还有就是关于 3D 空间的碰撞使用 2D 游戏通过四边形之间的相交判断就不足以应对了，我们需要使用浮点来完成计算，当大量的子弹和物品碰撞相交检测还会有性能方面问题，以及地形与物体的碰撞

## 14.3 绘制三角形

依然还是熟悉的绘制三角形，不过这次的参数已经变成了 3 个，绘制由 drawTriangle3D 来代替了 drawTriangle2D

书中描述了 x,y,z 表示的意思

x：范围 0-640 超出不绘制

y：范围 0-480 超出不绘制

z：深度 方向是由内向外的

## 14.4 按位置前后绘制物体

书中例子：两个三角形都设置了 z 轴为什么远处的（z=1）的三角形覆盖了近处的（z=0）的三角形 ，书上也有解释`执行代码顺序绘制三角形，后绘制的三角形会覆盖之前绘制的三角形`

这里需要使用一些特殊处理，使被遮挡的面不可见，`隐藏面消除`

z-Sort

    显然从上面的原因解释中就可以知道只要先渲染最远的物体就可以了，这样近处的物体就会遮挡远处的图像（按照z的大小排序依次绘制三角形）

    好处是这块不需要额外的内存开销，曾经广泛使用，现在某些情况也会使用（以前常用，现在有更好的方法可以替代）

    *但是 如果一个三角形中的z轴不在统一z轴上怎么办呢  z-Sort就不适用了

Z 缓存

    `如果一个三角形中的z轴不在统一z轴`这以前是很棘手的问题，但是硬件进步问题也解决了。绘制的最小单位是像素，我们可以统计出每个像素被绘制时的z坐标，`给每个像素做Z排序？？？`这样就可以使用三角形为单位，而用更小的像素作为单位来判断前后关系

    其中记录各个像素z坐标区域称为z缓存（z-Buffer）,使用这个方法来判断前后关系被叫做`Z缓存法`，过程被叫做z-Test，也被叫做depthBeffer或者 depthTest

### 14.4.1 半透明与 Z 缓存

enableDeptTest()函数是为了 Z 缓存无法发挥作用或者明确禁止使用 Z 缓存时而保留的

- Z 缓存无法发挥作用的情况

  `有一个半透明三角形，和之前处理一样使用setBlendModel()来开启透明混合，混合后遮挡部分会被忽略`

  ```C++
  double count = 0;
  bool isInit = false;
  void Framework::update()
  {
  	if (!isInit)
  	{
  		isInit = true;
  	}
  	//double point1[3] = { 500.00,300.00,0.5 };
  	//double point2[3] = { 300.00,500.00,0.5 };
  	//double point3[3] = { 300.00,300.00,-count };
  	//drawTriangle3D(point1, point2, point3);
  	//count += 0.1;
  	enableDepthTest(true);
  	setBlendMode(BLEND_LINEAR);
  	//enableDepthWrite(true);  // 为true时 此时的倒三角中的颜色不正常  重叠区域理论上应该发生像素颜色混合  颜色应该与正三角的颜色一致
  	double point0[3] = { 200.0,100.0 ,1.0 };
  	double point1[3] = { 400.0,100.0 ,1.0 };
  	double point2[3] = { 300.0,400.0 ,0.0 };
  	unsigned c = 0x80ff0000;
  	drawTriangle3D(point0, point1, point2, 0, 0, 0, c, c, c);

  	double point3[3] = { 200.0,400.0 ,1.0 };
  	double point4[3] = { 400.0,400.0 ,1.0 };
  	double point5[3] = { 300.0,100.0 ,0.0 };
  	c = 0x8000ff00;
  	drawTriangle3D(point3, point4, point5, 0, 0, 0, c, c, c);

  }
  ```

  代码测试后看到会有两个重叠的三角形，正方向的三角形显示看着比较正常，完成了红绿颜色的混合，但是倒三角只是单纯的红色(这显然不对)理论上的结果应该是两个混和区域的三角形的颜色应该是一样的(enableDeptWrite 设置为 false 时两个混合后的颜色一样)
  `因为遵循如果像素被遮挡那么就忽略 所以需要执行Z-Test但是不写入Z缓存`

但是 Z-Sort 也有一些缺陷 如果透明三角形有上万个那么排序操作会很麻烦

要正确的绘制出透明的混合效果必须把所有的像素都保存下来，然后 z 值排序混合渲染，但是排序和所有像素取出并排序两个操作成本实在是太高，`折中一下忽略深处的像素来减少计算量，只取考前发两个图形进行运算`

但是只是采用`叠加混合`模式就没什么问题，因为这样的模式不忿先后顺序，但是`线性混合`模式不具备这样的特新，因为比例分配不是一样的

$f(a,b) = f(b,a)$ // 叠加混合  
$f(a,b) = a+t(b-a) =a+tb-ta$  
$f(b,a) = b+t(a-b) =b+ta-tb$

## 14.5 把远处的物体绘制得小一些

### 14.5.1 和距离成反比

简单点题：远近的比例尺，需要一个观察者视角

- 二维中的 A(x,y)B(x,y)两点距离 勾股定理
  - $\sqrt{(X_b-X_a)^2+(Y_b-Y_a)^2}$
- 三维中的 A(x,y,z)B(x,y,z) 两点距离 勾股定理
  - $\sqrt{(X_b-X_a)^2+(Y_b-Y_a)^2+(Z_b-Z_a)^2}$
- 将物体变小的方法
  - 现在要解决的问题是“被除数应该取什么值”

`使用Z轴来当作比例放大的除数,如果离得越近,除数越小，除数越小商越大`

`但是又衍生出一个问题设定顶点如果Z值超过1或者小于0那么就会使画面消失`

`以及在计算时除数为零时无意义`

如何避免呢：`既然是比例尺放大那么我们移动z轴使范围从0-1变为1-2`

`那Z轴相对*2了那么其他的参数也要相对的*2以保持比例与范围0-1时的比例一致`

```C++
#include "foo.h"
#include "GameLib/Framework.h"
#define Z_MAX_RANGE 2
#define Z_MIN_RANGE 1
namespace GameLib
{
	double count = 0;
	bool isInit = false;
	double position = Z_MIN_RANGE * 1000;
	int dist = 1;
	void Framework::update()
	{
		if (!isInit)
		{
			isInit = true;
		}

		enableDepthTest(true);
		setBlendMode(BLEND_LINEAR);
		enableDepthWrite(true);  // 为true时此时的倒三角中的颜色不正常  重叠区域理论上应该发生像素颜色混合  颜色应该与正三角的颜色一致
		// 深度距离z在0-1的范围中可以显示  如果超出了范围那么就不能显示了eg：-0.1 或是 2
		// 以下处理结束后使z不会因为为0时让图像消失  在某个值时突然覆盖整个画面
		double maxRange = 1000 * Z_MAX_RANGE;  // 使最大的Z为2  保证补间比例没有被扩大
		double minRange = 1000 * Z_MIN_RANGE;  // 使最小值Z为1  保证补间比例没有被扩大

		double resize = position / maxRange;  // 初始化图像  当前位置距离最大位置的比例
		//  经过比例1000的放大之后  position从0-1000来到了1000-2000 相对的maxRange也一样放大比例这样就保证不会因为移动Z轴区间导致图像比例错误

		//  距离与点位的比例
		double point0[3] = { 0.0 / resize,0.0 / resize ,resize };
		double point1[3] = { 300.0 / resize,0.0 / resize ,resize };
		double point2[3] = { 0.0 / resize,300.0 / resize ,resize };
		unsigned c = 0x80555555;
		drawTriangle3D(point0, point1, point2, 0, 0, 0, c, c, c);

		double point3[3] = { 300.0 / resize,300.0 / resize ,resize };
		double point4[3] = { 300.0 / resize,0.0 / resize ,resize };
		double point5[3] = { 0.0 / resize,300.0 / resize ,resize };
		c = 0x80555555;
		drawTriangle3D(point3, point4, point5, 0, 0, 0, c, c, c);
		if ((position += dist) > maxRange)
		{
			dist = -1;
		}
		if ((position += dist) < minRange)
		{
			dist = 1;
		}
	}
}

```

- 原点的移动
  首先计算上下左右的偏移位置

```C++
	p[i][0] += gXMove;
	p[i][2] += gZMove;
```

然后计算大小比例

```C++
	p[i][0] *= 640.0 / p[i][2]; // 比例算// 新代码
	p[i][1] *= 640.0 / p[i][2]; // 比例换算// 新代码
```

最后将顶点坐标移动到中心位置

```C++
	p[i][0] += 320.0f;					  // 新代码
	p[i][1] += 240.0f;					  // 新代码
```

- 大小的问题

### 14.5.2 该方法存储在问题

- 视角位于三角形内部

当处于三角形内部时向一个角看去 你视角后方的两个点就超出了你的可视范围（z<0）这违反了除数不能为 0 的规定，所以无法正确绘制三角形，所以需要对三角形仅限分割，避免横跨 z=0 的平面

- 纹理坐标的补间问题

### 14.5.3 通过显完成

这里引入了一个新的的元素 w 这个元素如果是 2d 的情况也许就够了，但是 3d 的情况需要需要对 z 元素一起进行变换，那么一个会变换的值就`不能作为变换的标准`，理解过来是这样的一个意思

函数从 drawTriangle3D 变为 3DH，这里的 H 表示 Homogeneous（齐次）的缩写

- 传给显卡的顶点

我们现在传给显卡的顶点坐标和之前有些不通

| -                                                       | -                    |
| ------------------------------------------------------- | -------------------- |
| x 和 y 的范围是-1 到 1                                  | 超出范围显卡不做绘制 |
| y 轴上方为正方向                                        | 是右下为正           |
| w 用于存储 x，y，z 的除数值（换算过来相当于是缩放比例） | -                    |

- 新概念`横纵比`
  简单描述：如果显示器是一个 4 比 3 的显示器 那么需要绘制一个正方形 将正方形的横向除以 4 纵除以 3 那么会得到一个长方形 这和原来是图形不符合，这里需要把缩放统一，书中描述可以是`横向收缩`或是`纵向拉伸`也就是谁做被除数的问题可以是 3/4 或者是 4/3 都是统一顶点缩放

- y 轴方向问题，在 3D 游戏中，将上方作为 y 轴的正方向比较好，如果高度越高那么 y 值越小这不像常理

- w 值，w 存储着 xyz 的除数，z 也要进行除法运算，当前因为 z 存储的是将要写入 z 缓存的值，显卡处理时将除以 w，这样 z 缓存的值就错了，需要将 z 缓存的值乘以 w，然后赋值给 z，这样才不会错

- 理论上 w 也要除以自身保证自身为 1，像 n+1 元向量来表示 n 元向量的做法称为齐次坐标

## 14.6 坐标变换

将矩阵引入到 3D 处理中

### 14.6.1 坐标轴的方向

| 坐标变换 | 描述         |
| -------- | ------------ |
| X        | 左->右（正） |
| Y        | 下->上（正） |
| Z        | 前->后（正） |

Z 轴是作者挖的坑后面解释 **_（这边我先提前理解一下，也许是相对移动的问题，你在玩 3D 射击游戏时候你人向前走那么物体是离你越来越远还是越来越近呢。如果是按照原先的越按前进键物品就会理你越来越远，这确实前进使得数值增加了，但是`你越向前物品离你越远`，这不符合实际的模拟情况，应该是向前时相对的物品离你越来越近，反之书中描述的虽然不太符合数学，但是符合实际的逻辑，`你越向前物品离你越近`）_**

### 14.6.2 将 z 轴反转

将 z 轴设置朝外为正，在朝内为负后，z 轴和 Z-Buffer 的方向就不一样了，所以需要对 Z-Buffer 的范围变换公司进行调整

原先的范围是[1,10000],现在假定为[-10000,-1],-1 的位置是离我们最近的地方，我们把这个地方 Z-Buffer 设置为 0，而-10000 为远处，因此 Z-Buffer 应该设置成 1，范围公式和之前一样

$$Z=az+b$$
$$带入z范围之后$$
$$0=(-1)a+b$$
$$1=(-10000)a+b$$

$$1-0=(-10000)a+b-(-1)a-b$$
$$1=(-9999)a$$
$$a=-{\frac{1}{9999}}$$
$$带入0=(-1)a+b运算$$
$$b=-{\frac{1}{9999}}$$

扩展：近点-1 为 n，远点-10000 为 f

$$那么列出公式$$

$$0=-na+b$$
$$1=-fa+b$$

$$化简:$$

$$1-0=-fa+b-(-na+b)$$
$$1=-fa+na$$
$${\frac{1}{a}}=-f+n$$
$$1/{\frac{1}{a}} = 1/(-f+n)$$
$$a = {\frac{1}{n-f}}$$
$$带入0=-na+b$$
$$0 = -n({\frac{1}{n-f}})+b$$
$$-b = -n({\frac{1}{n-f}})$$
$$b = n({\frac{1}{n-f}})$$
$$b = {\frac{n}{n-f}}$$

$$结果是$$
$$b = {\frac{n}{n-f}}$$
$$a = {\frac{1}{n-f}}$$

这里n表示近裁剪面`near clip`,f表示远裁剪面`far clip`

### 14.6.3 矩阵与向量的扩充

一个四边形需要4个顶点，需要利用矩阵完成移动，缩放，旋转